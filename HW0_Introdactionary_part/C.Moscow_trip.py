"""
Ограничение времени	- 2 секунда
Ограничение памяти	- 256Mb

Мэрия Москвы основательно подготовилась к празднованию тысячелетия города в 2147 году,
построив под столицей бесконечную асфальтированную площадку, чтобы заменить все
существующие в городе автомобильные дороги. В память о кольцевых и радиальных дорогах
разрешили двигаться по площадке только двумя способами:

В сторону точки начала координат или от неё. При этом из точки начала координат
разрешено двигаться в любом направлении.
Вдоль окружности с центром в начале координат и радиусом, который равен текущему расстоянию
до начала координат. Двигаться вдоль такой окружности разрешается в любом направлении
(по или против часовой стрелки).
Вам, как ведущему программисту ответственной инстанции поручено разработать модуль,
который будет определять кратчайший путь из точки A, с координатами (xA, yA) в точку B
с координатами (xB, yB). Считайте, что менять направление движения можно произвольное
количество раз, но оно должно всегда соответствовать одному из двух описанных выше вариантов.

Формат ввода
В первой строке ввода заданы четыре целых числа xA, yA, xB и yB, по модулю не превосходящие 106.

Формат вывода
Выведите одно число — минимальное расстояние, которое придётся преодолеть по пути
из точки A в точку B, если не нарушать правил дорожного движения.
Ваш ответ будет принят, если его абсолютная или относительная погрешность не превосходит 10-6.

Пример
Ввод
0 5 4 3
Вывод
4.636476090008
"""

import math

Xa, Ya, Xb, Yb = map(int, input().split())

#посчитаем длину отрезков от начала координат до каждой точки
a0, b0 = math.sqrt(Xa * Xa + Ya * Ya), math.sqrt(Xb * Xb + Yb * Yb)

#с помощью функции atan найдем угол между точками
#!!! Важно использовать atan, поскольку cos дает немного другой ответ (погрешность)
angle1 = math.atan2(Ya, Xa) - math.atan2(Yb, Xb)
angle = angle1 if angle1 < math.pi else math.pi*2 - angle1

#движемся по наименьшей окружности и находим весь путь сложением отрезков пути
circle_line = min([a0 * angle, b0 * angle])
line_way = a0 + b0
circ_way = circle_line + abs(b0 - a0)
print(min([line_way, circ_way]))


#Другое решение ( с использованием cos - дает погрешность)
'''
import math

Xa, Ya, Xb, Yb = map(float, input().split())

#посчитаем длину отрезков от начала координат до каждой точки
a0, b0 = (Xa ** 2 + Ya ** 2) ** 0.5, (Xb ** 2 + Yb ** 2) ** 0.5

#найдем cos (скалярное произведение векторов разделим на произведение их длин), а потом угол  
cos = round((Xa * Xb + Ya * Yb) / (a0*b0), 15) if (a0 != 0 and b0 != 0) else 0
angle = round(math.acos(cos), 14)

#движемся по наименьшей окружности и находим весь путь сложением отрезков пути
circle_line = min([round(a0 * angle, 14), round(b0 * angle, 14)])
line_way = a0 + b0
circ_way = circle_line + abs(b0 - a0)
print(min([line_way, circ_way]))
'''